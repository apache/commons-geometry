/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.geometry.euclidean.threed;

import java.io.File;
import java.io.IOException;
import java.io.Writer;
import java.nio.file.Files;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.stream.Stream;

import org.apache.commons.geometry.core.precision.DoublePrecisionContext;
import org.apache.commons.geometry.euclidean.twod.ConvexArea;
import org.apache.commons.geometry.euclidean.twod.Polyline;

/** This class creates simple OBJ files from {@link BoundarySource3D} instances.
 * The output files can be opened in a 3D viewer for visual debugging of 3D
 * regions. This class is only intended for use in testing.
 *
 * @see https://en.wikipedia.org/wiki/Wavefront_.obj_file
 */
public final class OBJWriter {

    /** Utility class. */
    private OBJWriter() {
        // no instantiation
    }

    /** Writes an OBJ file representing the given {@link BoundarySource3D}. An exception is
     * thrown if infinite boundaries are encountered.
     * @param filePath The path of the file to write
     * @param poly The input boundary source
     * @throws IOException
     */
    public static void write(final String filePath, final BoundarySource3D boundarySrc,
            final DoublePrecisionContext precision) throws IOException {
        write(new File(filePath), boundarySrc, precision);
    }

    /** Write an OBJ file representing the given {@link BoundarySource3D}. An exception is
     * thrown if infinite boundaries are encountered.
     * @param file The file to write
     * @param poly The input boundary source
     * @throws IOException
     */
    public static void write(final File file, final BoundarySource3D boundarySrc,
            final DoublePrecisionContext precision) throws IOException {
        // get the vertices and faces
        final MeshBuilder meshBuilder = new MeshBuilder(precision);
        try (Stream<PlaneConvexSubset> stream = boundarySrc.boundaryStream()) {
            stream.forEach(meshBuilder::add);
        }

        // write them to the file
        try (Writer writer = Files.newBufferedWriter(file.toPath())) {
            writer.write("# Generated by " + OBJWriter.class.getName() + " on " + new Date() + "\n");
            writeVertices(writer, meshBuilder.getVertices());
            writeFaces(writer, meshBuilder.getFaces());
        }
    }

    /** Writes the given list of vertices to the file in the OBJ format.
     * @param writer
     * @param vertices
     * @throws IOException
     */
    private static void writeVertices(final Writer writer, final List<Vector3D> vertices) throws IOException {
        final DecimalFormat df = new DecimalFormat("0.######");

        for (final Vector3D v : vertices) {
            writer.write("v ");
            writer.write(df.format(v.getX()));
            writer.write(" ");
            writer.write(df.format(v.getY()));
            writer.write(" ");
            writer.write(df.format(v.getZ()));
            writer.write("\n");
        }
    }

    /** Writes the given list of face vertex indices to the file in the OBJ format. The indices
     * are expected to be 0-based and are converted to the 1-based format used by OBJ.
     * @param writer
     * @param faces
     * @throws IOException
     */
    private static void writeFaces(final Writer writer, final List<int[]> faces) throws IOException {
        for (int[] face : faces) {
            writer.write("f ");
            for (int idx : face) {
                writer.write(String.valueOf(idx + 1)); // obj indices are 1-based
                writer.write(" ");
            }
            writer.write("\n");
        }
    }

    /** Class used to impose a strict sorting on 3D vertices.
     * If all of the components of two vertices are within tolerance of each
     * other, then the vertices are considered equal. This helps to avoid
     * writing duplicate vertices in the OBJ output.
     */
    private static class VertexComparator implements Comparator<Vector3D> {

        /** Precision context to deteremine floating-point equality */
        private final DoublePrecisionContext precision;

        /** Creates a new instance with the given tolerance value.
         * @param tolerance
         */
        VertexComparator(final DoublePrecisionContext precision) {
            this.precision = precision;
        }

        /** {@inheritDoc} */
        @Override
        public int compare(final Vector3D a, final Vector3D b) {
            int result = precision.compare(a.getX(), b.getX());
            if (result == 0) {
                result = precision.compare(a.getY(), b.getY());
                if (result == 0) {
                    result = precision.compare(a.getZ(), b.getZ());
                }
            }
            return result;
        }
    }

    /** Class for building a list of vertices and face vertex indices from
     * 3D boundaries.
     */
    private static class MeshBuilder {

        /** Map of vertices to their index in the vertices list */
        private Map<Vector3D, Integer> vertexIndexMap;

        /** List of unique vertices in the BSPTree boundary */
        private List<Vector3D> vertices;

        /**
         * List of face vertex indices. Each face will have 3 indices. Indices
         * are 0-based.
         * */
        private List<int[]> faces;

        /** Creates a new instance with the given tolerance.
         * @param tolerance
         */
        MeshBuilder(final DoublePrecisionContext precision) {
            this.vertexIndexMap = new TreeMap<>(new VertexComparator(precision));
            this.vertices = new ArrayList<>();
            this.faces = new ArrayList<>();
        }

        /** Returns the list of unique vertices found in the BSPTree.
         * @return
         */
        public List<Vector3D> getVertices() {
            return vertices;
        }

        /** Returns the list of 0-based face vertex indices for the BSPTree. Each face is
         * a triangle with 3 indices.
         * @return
         */
        public List<int[]> getFaces() {
            return faces;
        }

        /** Add a convex subplane boundary to this mesh.
         * @param subplane
         */
        public void add(final PlaneConvexSubset subplane) {
            if (!subplane.isEmpty()) {
                if (!subplane.isFinite()) {
                    throw new IllegalArgumentException("Cannot add infinite convex subplane to mesh: " + subplane);
                }

                final ConvexArea area = subplane.getSubspaceRegion();
                for (final Polyline boundaryPath : area.getBoundaryPaths()) {
                    final List<Vector3D> subplaneVertices = subplane.getPlane().toSpace(boundaryPath.getVertexSequence());

                    // use a triangle fan to add the path
                    final Vector3D p0 = subplaneVertices.get(0);
                    for (int i = 2; i < subplaneVertices.size(); ++i) {
                        faces.add(new int[] {
                                getVertexIndex(p0),
                                getVertexIndex(subplaneVertices.get(i - 1)),
                                getVertexIndex(subplaneVertices.get(i))
                        });
                    }
                }
            }
        }

        /** Returns the 0-based index of the given vertex in the <code>vertices</code>
         * list. If the vertex has not been encountered before, it is added
         * to the list.
         * @param vertex
         * @return
         */
        private int getVertexIndex(final Vector3D vertex) {
            Integer idx = vertexIndexMap.get(vertex);
            if (idx == null) {
                idx = vertices.size();

                vertices.add(vertex);
                vertexIndexMap.put(vertex, idx);
            }
            return idx.intValue();
        }
    }
}
